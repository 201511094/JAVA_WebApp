13. 제네릭

[13.1] 제네릭을 사용하는 이유
* 제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있게 되었다.
 - 자바5부터 추가됨
* 제네릭은 클래스, 인터페이스, 메소드를 정의할 때 타입을 파라미터로 사용할 수 있도록 한다.
* 타입 파라미터는 코드 작성 시 구체적인 타입으로 대체되어 다양한 코드를 생성하도록 해준다.
* 제네릭을 사용한 코드의 이점
 - 컴파일 시 강한 타입 체크를 할 수 있어 에러를 사전에 방지함
 - 타입 변환(casting)을 제거하여 프로그램 성능이 향상됨

[13.2] 제네릭 타입
* 제네릭 타입은 타입을 파라미터로 가지는 클래스와 인터페이스이다.
* 제네릭 타입은 클래스, 인터페이스 이름 뒤에 "<>"부호가 붙고 사이에 타입 파라미터가 위치한다.
* 제네릭 타입을 실제 코드에서 사용하려면 타입 파라미터에 구체적인 타입을 지정해야 한다.
* 제네릭은 모든 종류의 객체를 저장하면서 타입 변환이 발생하지 않도록 한다.
* 제네릭은 클래스를 설계할 때 구체적인 타입을 명시하지 않고 타입 파라미터로 대체했다가 실제 클래스가 사용될 때 구체적인 타입을 지정한다.
 - 타입 변환을 최소화시킴

[13.3] 멀티 타입 파라미터(class<K,V,...>, interfave<K,V,...>)
* 제네릭 타입은 두 개 이상의 멀티 타입 파라미터를 사용할 수 있으며 콤마로 구분한다.
* 자바7부터 제네릭 타입 파라미터의 중복 기술을 줄이기 위해 다이아몬드 연산자<>를 제공한다.
 - 자바 컴파일러는 타입 파라미터 부분에 <>연산자를 사용하면 타입 파라미터를 유추해서 자동으로 설정해줌

[13.4] 제네릭 메소드(<T,R> R method(T t))
* 제네릭 메소드는 매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드이다.
* 선언 시 리턴 타입 앞에 <>기호를 추가하고 타입 파라미터를 기술한 다음 리턴 타입과 매개 타입으로 타입 파라미터를 사용한다.
 - public <타입파라미터,...> 리턴타입 메소드명(매개변수,...) {...}
 - public <T> Box<V> boxing(T t) {...}
* 제네릭 메소드를 호출하는 방법
 - 코드에서 타입 파라미터의 구체적인 타입을 명시적으로 지정
 - 컴파일러가 매개값의 타입을 보고 구체적인 타입을 추정


[13.5] 제한된 타입 파라미터(<T extends 최상위타입>)
* 타입 파라미터에 지정되는 구체적인 타입을 제한할 경우 제한된 타입 파라미터가 필요하다.
* 타입 파라미터 뒤에 extends키워드를 붙이고 상위 타입을 명시한다.
 - 인터페이스에서도 implements가 아닌 extends를 사용함
* 타입 파라미터에 지정되는 구체적인 타입은 상위 타입이거나 상위 타입의 하위 또는 구현 클래스만 가능하다.
* 메소드의 중괄호 안에서 사용 가능한 것은 상위 타입의 멤버(필드, 메소드)로 제한된다.
 - 하위 타입에만 있는 필드와 메소드는 사용 불가

[13.6] 와일드카드 타입(<?>, <? extends ...>, <? super ...>)
* 코드에서 ?는 와일드카드라고 부른다.
* 제네릭 타입을 매개값이나 리턴 타입으로 사용할 때 구체적인 타입 대신 와일드카드를 세 가지 형태로 사용할 수 있다.
 - 제네릭타입<?>: Unbounced Wildcads(제한 없음)
 - 제네릭타입<? extends 상위타입>: Upper Bounded Wildcards(상위 클래스 제한)
 - 제네릭타입<? super 하위타입>: Lower Bounded Wildcards(하위 클래스 제한)

[13.7] 제네릭 타입의 상속과 구현
* 제네릭 타입도 부모 클래스가 될 수 있다.
* 자식 제네릭 타입은 추가적으로 타입 파라미터를 가질 수 있다.
 - public class ChildProduct<T,M,C> extends Product<T,M> {...}
* 제네릭 인터페이스를 구현한 클래스도 제네릭 타입이 된다.
 - 제네릭 인터페이스를 구현한 클래스도 제네릭 타입이어야 함

[13.n] 확인문제

