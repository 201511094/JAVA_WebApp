1. 스레드에 대한 설명
* 자바 애플리케이션은 메인 스레드가 main()메소드를 실행시킨다.
* 작업 스레드 클래스는 Thread클래스를 상속해서 만들 수 있다.
* Runnable객체는 스레드가 실행해야 할 코드를 가지고 있는 객체라고 볼 수 있다.
* 스레드 실행을 시작하려면 start()메소드를 호출해야 한다.

3. 스레드의 우선순위
* 우선순위가 높은 스레드가 실행 기회를 더 많이 가질 수 있다.
* 우선순위는 1부터 10까지 줄 수 있으며 디폴트는 5이다.
* Thread클래스는 NORM_PRIORITY, MIN_PRIORITY, MAX_PRIORITY 상수를 제공한다.
* 1은 가장 낮은 우선순위이다.

4. 동기화 메소드와 동기화 블록
* 동기화 메소드와 동기화 블록은 싱글(단일) 스레드 환경에서는 필요 없다.
* 스레드가 동기화 메소드를 실행할 때,
 - 다른 스레드는 일반 메소드를 호출할 수 있다.
 - 다른 스레드는 다른 동기화 메소드를 호출할 수 없다.
* 스레드가 동기화 블록을 실행할 때 다른 스레드는 다른 동기화 메소드를 호출할 수 없다.

5. 스레드 일시 정지 상태
* 일시 정지 상태는 BLOCKED, WAITING, TIMES_WAITING이 있다.
* 스레드가 동기화 메소드를 실행할 때 다른 스레드가 동기화 메소드를 호출하면 BLOCKED 일시 정지 상태가 된다.
* 동기화 메소드 내에서 wait()메소드를 호출하면 WAITING 일시 정지 상태가 된다.
* yield()메소드를 호출하면 TIMED_WAITING 실행 대기 상태가 된다. 일시 정지 상태는 sleep()메소드 호출 시.

6. 스레드 상태 제어를 하는 메소드
* yield()메소드를 호출한 스레드는 동일한 우선순위나 높은 우선순위의 스레드에게 실행 기회를 양보하고 자신은 실행 대기 상태가 된다.
* sleep()메소드를 호출한 스레드는 주어진 시간 동안 일시 정지 상태가 된다.
* stop()메소드는 스레드를 즉시 종료시키기 때문에 스레드 안전성에 좋지 못하다.
* join()메소드를 호출한 스레드는 일시 정지 상태가 된다.

7 interrupt()메소드를 호출한 효과
* 일시 정지 상태에서 InterruptedException을 발생시킨다.
* 실행 대기 상태에서 호출되면 일시 정지 상태가 될 때까지 InterruptedException이 발생하지 않는다.
* 아직 InterruptedException이 발생하지 않았다면 interrupted(), isInterrupted()메소드는 true를 리턴한다.

9. wait()와 notify()메소드
* 스레드가 wait()메소드를 호출하면 일시 정지 상태가 된다.
* 스레드가 notify()메소드를 호출하면 wait()로 일시 정지 상태에 있던 달느 스레드가 실행 대기 상태가 된다.
* wait()와 notify()는 동기화 메소드 또는 블록에서 호출할 필요가 없다.
* 스레드가 wait(long millis)를 호출하면 notify()가 호출되어야 실행 대기 상태가 된다.

11. while문으로 반복적인 작업을 하는 스레드를 종료시키는 방법
* 조건식에 boolean타입의 stop플래그를 이용해서 while문을 빠져나가게 한다.
* 스레드가 반복적으로 일시 정지 상태가 된다면 InterruptedException을 발생시켜 예외 처리 코드에서 break문으로 while문을 빠져나가게 한다.
* 스레드가 일시 정지 상태로 가지 않는다면 isInterrupted()나 interrupted()메소드의 리턴값을 조사해서 true일 경우 break문으로 while문을 빠져나가게 한다.

12. 스레드풀
* 갑작스러운 작업의 증가로 스레드의 폭증을 막기 위해 사용된다.
* ExecutorService객체가 스레드풀이며 newFixedThreadPool()메소드로 얻을 수 있다.
* 작업은 Runnable 또는 Callable인터페이스를 구현해서 정의한다.
* submit() 자체는 블로킹되지 않고 리턴값인 Future객체의 get()메소드 호출 시 스레드가 작업 완료시까지 블로킹된다.

13. Future객체
* Future객체는 결과값을 가진 객체가 아닌 지연 완료 객체이다.
* submit()메소드를 호출하면 즉시 리턴되는 객체이다.
* Future의 get()메소드는 스레드가 작업을 완료하기 전까지 블로킹된다.
* CompletionService를 이용하면 작업 완료된 순으로 Future를 얻을 수 있다.