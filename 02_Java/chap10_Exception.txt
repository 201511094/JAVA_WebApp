10. 예외 처리

[10.1] 예외와 예외 클래스
* 자바에서 에러란 응용프로그램 실행 오류가 발생하는 것이다.
 - 에러란 JVM 실행에 문제가 생겼다는 것
* 자바에서 예외는 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류이다.
 - 자바의 오류에는 에러와 예외가 있음
 - 예외가 발생하면 에러와 마찬가지로 프로그램이 곧바로 종료됨 -> 예외 처리를 통해 정상 실행 상태를 유지할 수 있음

* 예외의 종류: 일반 예외, 실행 예외 -> 두 가지 모두 예외 처리가 필요함
* 일반 예외(Exception)
 - 컴파일러 체크 예외, 자바 소스 컴파일 과정에서 예외 처리 코드가 필요한지 검사, 예외 처리 코드가 없으면 컴파일 오류
* 실행 예외(Runtime Exception)
 - 컴파일하는 과정에서 예외 처리 코드를 검사하지 않는 예외, 예외 처리 코드을 생략하더라도 컴파일이 되는 예외

* 자바에서는 예외를 클래스로 관리한다.
* JVM은 프로그램 실행 도중 예외가 발생하면 해당 예외 클래스로 객체를 생성하며 예외 처리 코드에서 객체를 이용할 수 있도록 해준다.
* 모든 예외 클래스들은 java.lang.Exception클래스를 상속받는다.
 - 일반 예외는 Exception을 상속받지만 RuntimeException을 상속받지 않는 클래스들
 - 실행 예외는 RuntimeException을 상속받는 클래스들 (RuntimeException도 Exception을 상속받음)
* JVM은 RuntimeException을 상속했는지 여부를 보고 실행 예외를 판단한다.

[10.2] 실행 예외
* 실행 예외는 자바 컴파일러가 체크하지 않기 때문에 개발자의 경험에 의해 예외 처리 코드를 삽입해야 한다.
* 자바 프로그램에서 자주 발생되는 실행 예외는 언제 발생하는지와 어떤 오류 메시지가 출력되는지 알아두어야 한다.

* NullPointerException
 - 객체 참조가 없는 상태, 즉 null값을 갖는 참조 변수로 객체 접근 연산자인 도트(.)를 사용했을 때 발생
 - 객체가 없는 상태에서 객체를 사용하려고 해서 발생한 예외
* ArrayIndexOutOfBoundsException
 - 배열에서 인덱스 범위를 초과하여 사용할 경우 발생한 예외
* NumberFormatException
 - 문자열로 되어 있는 데이터를 숫자로 변경할 때 숫자로 변환할 수 없는 문자가 포함되어 있을 경우 발생한 예외
* ClassCastException
 - 타입 변환은 상위 클래스와 하위 클래스 간에 발생하고 구현 클래스와 인터페이스 간에도 발생
 - 위와 같은 관계가 아니지만 억지로 타입 변환을 시도할 경우 발생한 예외

[10.3] 예외 처리 코드
* 예외 처리 코드란 프로그램에서 예외가 발생했을 경우 프로그램의 갑작스러운 종료를 막고 정상 실행을 유지할 수 있도록 처리하는 코드이다.
* 자바 컴파일러는 소스 파일을 컴파일할 때 일반 예외가 발생할 가능성이 있는 코드를 발견하면 컴파일 오류를 발생시킨다.
 - 개발자로 하여금 강제적으로 예외 처리 코드를 작성하도록 요구함
* 실행 예외는 컴파일러가 체크해주지 않기 때문에 예외 처리 코드를 개발자의 경험을 바탕으로 작성해야 한다.

* 예외 처리 코드는 try-catch-finally블록을 이용한다.
 - try-catch-finally블록은 생성자 내부와 메소드 내부에 작성되어 일반 예외와 실행 예외가 발생할 경우 예외 처리를 할 수 있게 해줌
 - try블록에는 예외 발생 코드가 위치, 예외가 발생하면 catch블록으로 이동하여 예외 처리 코드를 실행 후 finally블록의 코드를 실행
 - finally블록은 예외 발생 여부와 상관없이 항상 실행됨

[10.4] 예외 종류에 따른 처리 코드
* try블록 내부는 다양한 종류의 예외가 발생할 수 있다.
* 발생되는 예외별로 예외 처리 코드를 다르게 하려면 다중 catch블록을 작성하면 된다.
* catch블록의 예외 클래스 타입은 try블록에서 발생된 예외의 종류이며, try블록에서 해당 타입의 예외가 발생되면 catch블록을 실행하도록 되어 있다.
 - catch블록이 여러 개이더라도 단 하나의 catch블록만 실행됨 (하나의 예외가 발생하면 즉시 실행을 멈추고 해당 catch블록으로 이동하기 때문)

* 다중 catch블록을 작성할 때 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 한다.
 - 상위 예외 클래스의 catch블록이 위에 있으면 하위 예외 클래스의 catch블록이 실행되지 않음
 - 왜냐하면 하위 예외는 상위 예외를 상속했기 때문에 상위 예외 타입도 됨

* 자바7부터 하나의 catch블록에서 여러 개의 예외를 처리할 수 있도록 멀티catch기능이 추가되었다.
* 멀티catch블록은 catch 괄호( )안에 동일하게 처리하고 싶은 예외를 "|"로 연결하면 된다.

[10.5] 자동 리소스 닫기
* 자바7에서 추가된 try-with-resources를 사용하면 예외 발생 여부와 상관없이 사용했던 리소스 객체의 close( )메소드를 호출해서 안전하게 리소스를 닫아준다.
 - 리소스: 데이터를 읽고 쓰는 객체

* try-with-resources를 사용하기 위해서 리소스 객체는 java.lang.AutoCloseable인터페이스를 구현하고 있어야 한다. -> implements AutoCloseable
 - AutoCloseable에는 close( )메소드가 정의되어 있음
 - try-with-resources가 close( )메소드를 자동 호출

[10.6] 예외 떠넘기기
* 메소드 내부에서 예외가 발생할 수 있는 코드를 작성할 때 try-catch블록으로 예외를 처리하는 것이 기본이다.
* 하지만 경우에 따라 메소드를 호출한 곳으로 예외를 떠넘길 수 있고, 이 때 사용하는 키워드가 throws이다.
* throws키워드는 메소드 선언부 끝에 작성되어 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘기는 역할을 한다.
* throws키워드 뒤에는 떠넘길 예외 클래스를 쉼표로 구분해서 나열해준다.

* main( )메소드에서도 throws키워드를 사용해 예외를 떠넘길 수 있지만 결국 JVM이 최종적으로 예외 처리를 한다.
 - JVM은 예외의 내용을 콘솔에 출력하는 것으로 예외 처리를 함
* main( )메소드에서 throws Exception을 붙이는건 좋지 못한 예외 처리 방법이다.
 - 따라서 main( )에서 try-catch블록으로 예외를 최종 처리하는 것이 바람직함

[10.7] 사용자 정의 예외와 예외 발생
* 애플리케이션 예외란 애플리케이션 서비스와 관련된 예외이다. 개발자가 직접 정의해서 만들므로 사용자 정의 예외라고도 한다.
* 사용자 정의 예외 클래스는 일반 예외와 실행 예외 둘 다 선언할 수 있다.
 - 일반 예외는 컴파일러가 체크하는 예외 -> Exception상속
 - 실행 예외는 컴파일러가 체크하지 않는 예외 -> RuntimeException상속

* 사용자 정의 예외 클래스는 대부분 생성자 선언만을 포함하며 두 개를 선언하는 것이 일반적이다.
 - 매개 변수가 없는 기본 생성자
 - 예외 메시지를 전달하기 위한 String타입의 매개 변수를 갖는 생성자

* 코드에서 사용자 정의 예외 또는 자바 표준 예외를 발생시키기 위한 방법
 - throw new XXXException(); 또는 throw new XXXException("메시지");
* 예외 발생 코드를 가지는 메소드는 대부분 자신을 호출한 곳에서 예외를 처리하도록 throws키워드로 예외를 떠넘긴다.
* 따라서 throws키워드를 포함하는 메소드는 호출한 곳에서 try-catch문으로 예외 처리를 해주어야 한다.

[10.8] 예외 정보 얻기
* try블록에서 예외가 발생되면 예외 객체는 catch블록의 매개 변수에서 참조하게 되므로 매개 변수를 이용하여 예외 객체의 정보를 알 수 있다.
 - 모든 예외 객체는 Exception을 상속하기 때문에 Exception이 가지고 있는 메소드들을 모든 예외 객체(XXXException e)에서 호출 가능
* 예외를 발생시킬 때 String타입의 메시지를 갖는 생성자를 이용했다면 메시지는 자동적으로 예외 객체 내부에 저장된다.
 - catch블록에서 getMessage()메소드 리턴값으로 얻을 수 있음
* printStackTrace()는 예외 발생 코드를 추적해서 모두 콘솔에 출력한다. 
 - 어떤 예외가 어디에서 발생했는지 상세하게 출력, 프로그램 테스트 중 오류를 찾을 때 활용

[10.n] 확인문제
* 예외는 사용자의 잘못된 조작, 개발자의 잘못된 코딩으로 인한 프로그램 오류를 말한다.
* RuntimeException의 하위 예외는 컴파일러가 예외 처리 코드를 체크하지 않는다.

* try{}블록에서 return문을 사용해도 finally{}블록은 실행된다.

* throws는 생성자나 메소드의 선언 끝 부분에 사용되어 내부에서 발생된 예외를 떠넘긴다.
* throws 뒤에는 떠넘겨야 할 예외를 쉼표로 구분해서 기술한다.
* 모든 예외를 떠넘기기 위해 간단하게 throws Exception으로 작성할 수 있다.
* 예외를 호출한 곳으로 떠넘기기 위해 메소드 선언부에 작성된다.

* throw는 예외를 최초로 발생시키는 코드이다.
* 새로운 예외를 발생시키기 위해 사용되며 throw키워드 뒤에는 예외 객체 생성 코드가 온다.(new XXXException();)
* throw로 발생된 예외는 일반적으로 생성자나 메소드 선언부에 throws로 떠넘겨진다.