08. 인터페이스

[8.1] 인터페이스의 역할
* 자바에서 인터페이스는 객체의 사용 방법을 정의한 타입이다.
* 인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 중요한 역할을 한다.
 - 자바8의 람다식은 함수적 인터페이스의 구현 객체를 생성하기 때문에 중요성이 더 커짐
* 인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다.
 - 개발 코드가 인터페이스의 메소드를 호출 -> 인터페이스는 객체의 메소드를 호출
 - 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 됨

* 개발 코드와 객체 사이 중간에 인터페이스를 두는 이유는 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해서이다.
 - 인터페이스는 여러 객체들과 사용이 가능하며 사용하는 객체에 따라 실행 내용과 리턴값이 다를 수 있음
 - 개발 코드 측면에서는 코드 변경 없이 실행 내용과 리턴값을 다양화할 수 있는 장점이 있음

[8.2] 인터페이스 선언
* 인터페이스는 "~.java"형태의 소스 파일로 작성되고 컴파일러(javac.exe)를 통해 "~.class"형태로 컴파일되기 때문에 물리적 형태는 클래스와 동일하다.
 - 소스 작성 시 선언 방법은 다름
* 인터페이스 선언 시 interface키워드를 사용한다.
* 인터페이스는 객체로 생성할 수 없기 때문에 생성자를 가질 수 없다.
 - 상수와 메소드만을 구성 멤버로 가짐
 - 자바8부터 디폴트 메소드와 정적 메소드도 선언이 가능

* 인터페이스는 객체 사용 설명서이므로 필드를 선언할 수 없지만 상수 필드는 선언이 가능하다.
 - 상수는 public static final로 선언, 선언과 동시에 초기값을 지정해야 함 (public, static, final 생략 가능)

* 추상 메소드는 객체가 가지고 있는 메소드를 설명한 것이며 호출 시 필요한 매개값과 리턴 타입만 알려준다.
 - 인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행되므로 인터페이스의 메소드는 실행 블록이 필요 없는 추상 메소드로 선언함
 - 인터페이스에 선언된 추상 메소드는 모두 public abstract의 특성을 가짐(public abstract 생략 가능) -> 메소드 선언부, 호출 방법만 기술

* 디폴트 메소드는 인터페이스에 선언되지만 사실 객체(구현 객체)가 가지고 있는 인스턴스 메소드라고 생각해야 한다.
 - 자바8에서 추가된 인터페이스의 새로운 멤버
 - 형태는 인스턴스 메소드와 동일, default키워드가 리턴 타입 앞에 붙음
 - 디폴트 메소드는 public 특성을 가짐 (public 생략 가능)

* 정적 메소드도 자바8부터 작성할 수 있으며, 디폴트 메소드와 달리 객체가 없어도 인터페이스만으로 호출이 가능하다.
 - 자바8에서 추가된 인터페이스의 새로운 멤버, 클래스의 정적 메소드와 형태가 완전 동일
 - 정적 메소드는 public 특성을 가짐 (public 생략 가능)

[8.3] 인터페이스 구현
* 개발 코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다.
* 객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 한다.
* 이러한 객체를 인터페이스의 구현 객체라고 하고, 구현 객체를 생성하는 클래스를 구현 클래스라고 한다.

* 구현 클래스는 인터페이스 타입으로 사용할 수 있음을 알리기 위해 클래스 선언부에 implements키워드를 추가하고 인터페이스명을 명시해야 한다.
* 인터페이스에 선언된 추상 메소드의 실체 메소드를 선언해야 한다.
 - 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 가지므로 public보다 더 낮은 접근 제한으로 작성할 수 없음
 - public 생략 시 컴파일 에러
 - 인터페이스에 선언된 추상 메소드에 대응하는 실체 메소드를 구현 클래스가 작성하지 않으면 구현 클래스는 자동으로 추상 클래스가 됨
 - 따라서 클래스 선언부에 abstract키워드를 추가해야 함

* 인터페이스로 구현 객체를 사용하려면 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다.
 - 인터페이스 변수는 참조 타입이므로 구현 객체가 대입될 경우 구현 객체의 번지를 저장함

* 구현 클래스를 만들어 사용하는 것이 일반적이고 클래스 재사용이 편리하지만 일회성의 구현 객체를 만들기 위해 소스 파일과 클래스를 만드는 것은 비효율적이다.
* 익명 구현 객체란 소스 파일을 만들지 않고도 구현 객체를 만들 수 있는 방법이다.
 - UI 프로그래밍에서 이벤트 처리 또는 임시 작업 스레드를 만들 때 익명 구현 객체를 많이 활용
 - 자바8에서 지원하는 람다식은 인터페이스의 익명 구현 객체를 만듦
* 모든 객체는 클래스로부터 생성되며 익명 구현 객체도 마찬가지이다. (클래스이름$생성번호.class)

* 객체는 다수의 인터페이스 타입으로 사용할 수 있다.
* 다중 인터페이스를 구현할 경우 구현 클래스는 모든 인터페이스의 추상 메소드에 대해 실체 메소드를 작성해야 한다.
 - 하나라도 없으면 추상 클래스로 선언해야 함

[8.4] 인터페이스 사용
* 구현 객체가 인터페이스 타입에 대입되면 인터페이스에 선언된 추상 메소드를 개발 코드에서 호출할 수 있게 된다.
* 디폴트 메소드는 인터페이스에 선언되지만 인터페이스에서 바로 사용할 수 없다.
 - 디폴트 메소드는 인스턴스 메소드이므로 구현 객체가 있어야 사용 가능
* 디폴트 메소드는 인터페이스의 모든 구현 객체가 가지고 있는 기본 메소드이며 재정의(오버라이딩)할 수 있다.

[8.5] 타입 변환과 다형성
* 인터페이스도 다형성을 구현하는 기술이 사용된다.
 - 인터페이스 타입에 어떤 구현 객체를 대입하느냐에 따라 실행 결과가 달라짐
* 인터페이스를 사용해서 메소드를 호출하도록 코딩을 했다면 구현 객체를 교체하는 것은 매우 간단하다.
 - 프로그램 소스는 변화 없지만 구현 객체를 교체함으로써 프로그램의 실행 결과가 다양해짐 -> 인터페이스의 다형성
* 인터페이스 타입으로 매개변수를 선언하면 메소드 호출 시 매개값으로 여러 가지 종류의 구현 객체를 줄 수 있으므로 실행 결과가 다양하게 나온다. -> 인터페이스 매개 변수의 다형성

* 구현 객체가 인터페이스 타입으로 변환되는 것은 자동 타입 변환이다.
 - 자동 타입 변환: 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것
* 인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체도 인터페이스 타입으로 자동 타입 변환시킬 수 있다.
* 자동 타입 변환을 이용하여 필드의 다형성과 매개 변수의 다형성을 구현할 수 있다.
 - 필드와 매개 변수의 타입을 인터페이스로 선언

* 필드의 다형성은 메소드 수정 없이도 다양한 실행 결과를 얻을 수 있는 것이다.
* 인터페이스 배열로 구현 객체를 관리할 수 있다.
 - 구현 객체를 배열로 관리하면 제어문에서 가장 많이 혜택을 봄

* 매개값을 다양화하기 위해서 매개 변수를 인터페이스 타입으로 선언하고 호출할 때에는 구현 객체를 대입한다.
* 매개 변수의 타입이 인터페이스일 경우 어떠한 구현 객체도 매개값으로 사용할 수 있고 어떤 구현 객체가 제공되느냐에 따라 메소드의 실행 결과가 다양해질 수 있다. -> 매개 변수의 다형성

* 구현 객체가 인터페이스 타입으로 자동 변환되면 인터페이스에 선언된 메소드만 사용 가능하다는 제약이 따른다.
* 경우에 따라 구현 클래스에 선언된 필드와 메소드를 사용해야 할 경우가 있는데 이 때 강제 타입 변환(Casting)을 사용한다.
 - 강제 타입 변환으로 다시 구현 클래스 타입으로 변환한 다음 구현 클래스의 필드와 메소드를 사용함
* 강제 타입 변환은 구현 객체가 인터페이스 타입으로 변환되어 있는 상태에서 가능하다.
 - 어떤 구현 객체가 인터페이스 타입으로 변환되어있는지 확인하기 위해서 instanceof연산자를 사용함

[8.6] 인터페이스 상속
* 인터페이스는 클래스와 달리 다중 상속을 허용한다. extends키워드 뒤에 상속할 인터페이스들을 나열할 수 있다.
* 하위 인터페이스를 구현하는 클래스는 하위와 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 한다.
 - 구현 클래스로부터 객체를 생성하고 나서 하위 및 상위 인터페이스 타입으로 변환이 가능
* 하위 인터페이스로 타입 변환이 되면 하위 및 상위 인터페이스에 선언된 모든 메소드를 사용 가능하다.
* 상위 인터페이스로 타입 변환되면 상위 인터페이스에 선언된 메소드만 사용 가능하며 하위 인터페이스에 선언된 메소드는 사용할 수 없다.

[8.7] 디폴트 메소드와 인터페이스 확장
* 디폴트 메소드는 인터페이스에 선언된 인스턴스 메소드이기 때문에 구현 객체가 있어야 사용 가능하다.
 - 선언은 인터페이스에서, 사용은 구현 객체를 통해서
* 인터페이스에서 디폴트 메소드를 허용한 이유는 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서이다.
 - 기존 인터페이스의 이름과 추상 메소드의 변경 없이 디폴트 메소드만 추가할 수 있음
 - 이전에 개발한 구현 클래스를 그대로 사용할 수 있고 새롭게 개발한느 클래스는 디폴트 메소드를 활용할 수 있음
* 디폴트 메소드는 추상 메소드가 아니기 때문에 구현 클래스에서 실체 메소드를 작성할 필요가 없다.

* 부모 인터페이스에 디폴트 메소드가 정의되어 있을 경우 자식 인터페이스에서 디폴트 메소드를 활용할 수 있다.
 - 디폴트 메소드를 단순히 상속만 받음
 - 디폴트 메소드를 재정의(오버라이딩)해서 실행 내용을 변경
 - 디폴트 베소드를 추상 메소드로 재선언함

[8.n] 확인문제
* 구현 클래스가 인터페이스의 추상 메소드에 대한 실체 메소드를 가지고 있지 않으면 추상 클래스가 된다.
* 인터페이스는 인스턴스 필드를 가질 수 없다. 상수 필드만 가질 수 있다.
* 구현 객체는 인터페이스 타입으로 자동 변환된다.
* 구현 객체를 인터페이스 타입으로 변환하려면 강제 타입 변환이 아닌 자동 타입 변환을 해야 한다.