06. 클래스

[6.1] 객체 지향 프로그래밍(Object Oriented Programming)
* 객체 지향 프로그래밍이란 부품에 해당하는 객체들을 먼저 만들고 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법이다.
* 객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것이다.
* 객체는 속성과 동작으로 구성된다. 속성은 필드, 동작은 메소드라고 부른다.
* 객체 모델링이란 현실 세계의 객체를 소프트웨어 객체로 설계하는 것이다.
 - 현실 세계 객체의 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정

* 소프트웨어에서 객체들은 각각 독립적으로 존재하고 다른 객체와 서로 상호작용하면서 동작한다.
 - 객체들 사이의 상호작용 수단은 메소드
 - 객체가 다른 객체의 기능을 이용하는 것은 메소드 호출
* 도트연산자(.)는 객체의 필드와 메소드에 접근할 때 사용한다.
* 매개값은 메소드를 실행하기 위해 필요한 데이터이고 리턴값은 메소드가 실행하고 나서 호출한 곳으로 돌려주는 값이다.
* 객체의 상호작용은 객체 간의 메소드 호출을 의미하며 매개값과 리턴값을 통해 데이터를 주고 받는다.

* 객체들 간의 관계: 집합관계, 사용관계, 상속관계
 - 집합관계에 있는 객체는 하나의 부품이고 하나는 완성품
 - 사용관계는 객체간의 상호작용
 - 상속관계는 상위객체를 기반으로 하위객체를 생성하는 관계

* 객체 지향 프로그래밍의 특징 3가지
* 특징1: 캡슐화
 - 객체의 필드와 메소드를 하나로 묶고 실제 구현 내용을 감추는 것
 - 외부로부터 객체를 보호하는 목적
 - 접근 제한자를 사용하여 객체의 필드와 메소드의 사용 범위를 제한함
* 특징2: 상속
 - 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 사용할 수 있도록 함
 - 코드 재사용, 생산성 향상(개발 시간 절약, 유지 보수 시간 최소화)
* 특징3: 다형성 (오버로딩, 오버라이딩, 연산자의 재정의)
 - 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질, 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해줌
 - 자바에서는 부모 클래스 또는 인터페이스의 타입 변환을 허용
 - 다형성을 통해 객체는 부품화가 가능함
 - 오버로딩: 함수이름 일치/매개변수 불일치 -> 사용자 편의
 - 오버라이딩: 리턴값/함수이름/매개변수 모두 일치, 재정의, 상속 받아 동작을 다르게 수행함
 - 연산자의 재정의: + 또는 -

[6.2] 객체와 클래스
* 메모리에서 사용하고 싶은 객체가 있다면 설계도로 해당 객체를 만들어야 한다.
* 자바에서의 설계도는 클래스이며 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.
* 클래스로 만들어진 객체를 해당 클래스의 인스턴스라고 하며 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다.
* 객체 지향 프로그래밍 개발 단계: 클래스 설계 -> 클래스를 가지고 사용할 객체를 생성 -> 생성된 객체를 이용

[6.3] 클래스 선언
* 일반적으로 소스 파일당 하나의 클래스를 선언한다.
* 두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일(.class)은 클래스 선언 개수만큼 생긴다.
* 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다.
* 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다.

[6.4] 객체 생성과 클래스 변수
* 클래스 선언 후 컴파일을 하면 설계도가 만들어진 것이다.
* new는 클래스로부터 객체를 생성시키는 연산자이고 생성된 객체는 메모리 힙 영역에 생성된다.
 - 메모리 내에 생성된 객체의 위치를 모르면 객체를 사용할 수 없음
 - new연산자는 힙 영역에 객체를 생성시킨 후 객체의 주소를 리턴함
 - 이 주소를 참조 타입인 클래스 변수에 저장하면 변수를 통해 객체를 사용할 수 있음
* 클래스의 용도: 라이브러리용, 실행용
 - 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계됨, 프로그램 전체에서 실행 클래스 1개를 제외한 나머지 모두가 라이브러리
 - 실행 클래스는 main( )메소드를 제공하는 역할
* 대부분의 객체 지향 프로그램은 라이브러리와 실행 클래스가 분리되어 있다.

[6.5] 클래스의 구성 멤버 (필드, 생성자, 메소드)
* 클래스에는 객체가 가져야 할 구성 멤버가 선언된다. 이 구성 멤버들은 생략되거나 복수 개가 작성될 수 있다.
 - 필드: 객체의 데이터가 저장되는 곳
 - 생성자: 객체 생성 시 초기화 역할 담당
 - 메소드: 객체의 동작에 해당하는 실행 블록

* 필드
 - 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
 - 선언 형태는 변수와 비슷하지만 필드를 변수라고 부르지는 않음
 - 변수는 생성자와 메소드 내에서만 사용되고 실행 종료 시 자동 소멸되지만, 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재함
 - 필드 선언은 어디서든 가능하지만 생성자와 메소드 중괄호 블록 내부에는 선언될 수 없음 -> 로컬 변수
 - 필드를 사용한다는 것은 필드값을 읽고 변경하는 작업
 - 클래스 외부에서 사용할 경우 클래스로부터 객체를 생성한 뒤 필드 사용 가능(필드는 객체에 소속된 데이터이므로 객체가 존재해야 하기 때문)

* 생성자
 - new연산자로 호출되는 특별한 중괄호 블록
 - 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것
 - 메소드와 비슷하게 생겼지만 클래스 이름으로 되어 있고 리턴 타입이 없음
 - 생성자가 성공적으로 실행되지 않고 예외(에러)가 발생했다면 객체는 생성되지 않음
 - 클래스 내부에 생성자 선언을 생략하면 컴파일러는 바이트 코드에 자동으로 기본 생성자를 추가시킴
 - 클래스에 명시적으로 선언한 생성자가 한 개라도 있으면 컴파일러는 기본 생성자를 추가하지 않음
 - 명시적인 생성자는 객체를 다양하게 초기화하기 위해 선언함, 명시적인 생성자가 있을 경우 반드시 이를 호출해서 객체를 생성해야 함
 - 객체가 생성될 때 다른 값으로 초기화를 하고 싶으면 생성자에서 초기값을 줄 수 있음
 - 객체 생성 시점에 외부의 다양한 값들로 초기화되어야 한다면(클래스 작성 시 초기값을 줄 수 없는 경우) 매개값을 받아 생성자에서 초기화를 해야함
* 생성자 오버로딩이란 매개 변수를 달리하는 생성자를 여러 개 선언하는 것이다.
* 생성자에서 다른 생성자를 호출할 때 this( )코드를 사용한다.
 - 생성자의 첫줄에서만 허용
 - this( )의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야 함
 - this( ) 다음에는 추가 실행문이 올 수 있으며 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 진행한다는 뜻
 
* 메소드
 - 객체의 동작에 해당하는 중괄호 블록, 이 블록이 가지고 있는 이름이 메소드 이름
 - 객체 간의 데이터 전달의 수단으로 사용됨
 - 메소드 호출 시 중괄호 블록의 모든 코드들이 순서대로 실행됨
* 메소드 선언은 선언부와 실행 블록으로 구성된다. 메소드 선언부를 메소드 signature라고도 한다.
* 메소드 선언 시 매개 변수의 개수를 모를 경우
 - 매개 변수를 배열 타입으로 선언하는 방법
 - 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법, "..."를 사용해서 매개변수를 선언하면 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성됨

* 리턴값이 있는 메소드일 경우 return문의 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 한다.
* return문 이후의 실행문은 결코 실행되지 않는다.

* 메소드 호출
 - 객체 내부에서 호출: 단순한 메소드 이름으로 호출
 - 객체 외부에서 호출: 클래스로부터 객체를 생성한 후 참조 변수와 도트 연산자를 사용해서 호출

* 메소드 오버로딩이란 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것이다.
 - 하나의 메소드 이름으로 여러 기능을 담는다는 뜻
 - 조건: 매개 변수의 타입, 개수, 순서 중 하나가 달라야 함, 매개 변수의 이름만 바꾸거나 리턴 타입만 바꾸는 것은 오버로딩이 아님
 - 필요한 이유: 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서
* 오버로딩된 메소드를 호출할 경우 JVM은 매개값의 타입을 보고 메소드를 선택한다. 타입이 일치하지 않을 경우 자동 타입 변환이 가능한지 검사한다.

[6.9] 인스턴스 멤버와 this
* 인스턴스 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드
 - 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.
 - 인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이 사용할 수 없음
* 객체는 자신을 "this"라고 한다.

[6.10] 정적 멤버와 static
* 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드이다.
 - 각각 정적 필드와 정적 메소드
* 정적 필드와 정적 메소드는 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다.
 - 클래스 로딩이 끝나면 바로 사용 가능
* 객체마다 가지고 있어야 할 데이터면 인스턴스로, 객체마다 가지고 있을 필요가 없는 공용 데이터라면 정적으로 선언하는 것이 좋다.
* 인스턴스 필드를 이용해서 실행해야 하면 인스턴스로, 인스턴스 필드를 이용하지 않으면 정적으로 선언하는 것이 좋다.

* 정적 요소는 클래스 이름으로 접근하는 것이 좋다.
* 정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통이다. 
* 계산이 필요한 초기화 작업일 경우 정적 필드를 위한 초기화 작업을 정적 블록에서 수행한다. static { ... }
 - 정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행됨
* 정적 메소드와 정적 블록은 객체가 없어도 실행되기 때문에 내부에 인스턴스 필드와 메소드를 사용할 수 없다.
 - 객체 자신의 참조인 this 키워드도 사용 불가능

* 전체 프로그램에서 단 하나의 객체만 만들도록 하는 것을 싱글톤이라고 한다,
 - 클래스 외부에서 new연산자로 생성자를 호출할 수 없도록 해야함 -> 생성자에 private 접근 제한자

[6.11] final 필드와 상수
* final필드는 초기값이 저장되면 이것이 최종적인 값이 되어 프로그램 실행 도중 수정할 수 없다.
* final필드의 초기값을 주는 방법
 - 필드 선언 시에
 - 생성자에서 -> 생성자는 final필드의 최종 초기화를 마쳐야 함
* 상수는 static이면서 final이어야 한다.
 - 선언 시에 초기값을 주거나 static블록에서 초기화를 할 수 있음

[6.12] 패키지
* 자바에서는 클래스를 저장 관리하기 위해 패키지를 사용한다.
* 패키지는 클래스를 유일하게 만들어주는 식별자 역할을 한다. 패키지가 다르면 클래스 이름이 같아도 다른 클래스로 인식한다.

[6.13] 접근 제한자
* 접근 제한자: public protected, default, private (>>접근제한이 강화>>)

* 클래스에 적용할 수 있는 접근 제한은 public과 default 두 가지이다.
 - default: 다른 패키지에서 사용 불가
 - public: 아무런 제한 없이 사용 가능, 라이브러리 클래스로 개발되어야 하는 클래스는 반드시 public 접근 제한을 가져야 함

* 생성자는 public, protected, default, private 접근 제한을 가질 수 있다.
* 자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일하다.
 - public: 모든 패키지에서 아무 제한 없이 생성자 호출 가능
 - protected: 같은 패키지에 속하는 클래스에서 생성자 호출 가능, 다른 패키지에 속한 클래스가 자식 클래스라면 호출 가능
 - default: 다른 패키지에서 호출 불가능
 - private: 오직 클래스 내부에서만 생성자 호출 및 객체 생성 가능

* 필드와 메소드는 public, protected, default, private 접근 제한을 가질 수 있다.
 - public: 필드와 메소드가 public이라면 클래스도 public 접근 제한을 가져야 함
 - protected: 같은 패키지에 속하는 클래스에서 사용 가능, 다른 패키지에 속한 클래스가 자식 클래스라면 사용 가능
 - default: 같은 패키지에서는 아무런 제한 없이 사용 가능, 다른 패키지에서는 불가능
 - protected: 패키지에 상관없이 필드와 메소드 사용 불가능, 오직 클래스 내부에서만 사용 가능

[6.14] Getter와 Setter 메소드
* 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다.
 - 객체의 무결성
* 메소드를 통해 데이터를 변경하는 방법을 선호한다.
 - 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개, 메소드를 통해 데이터에 접근하도록 유도
 - 메소드가 매개값을 검증할 수 있게 됨 -> Setter
* 외부에서 객체의 데이터를 읽을 때 메소드를 사용하는 것이 좋다.
 - 메소드로 필드값을 가공한 후 외부로 전달 -> Getter

* 클래스 선언 시 필드를 private로 선언해서 외부로부터 보호하고, 필드에 대한 Setter/Getter메소드를 작성해서 필드값을 안전하게 변경/사용하는 것이 좋다.
 - 필드 타입이 boolean일 경우 Getter는 is로 시작하는 것이 관례
 - 필드값이 읽기 전용일 경우 Getter만 선언하거나 Setter에 private 접근 제한을 선언

[6.15] 어노테이션
* 어노테이션은 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보(= 메타데이터)
* 어노테이션의 용도
 - 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
 - SW 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
 - 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공

[6.n] 확인문제
* 클래스의 구성 멤버: 필드, 생성자, 메소드

* 클래스가 반드시 필드와 메소드를 가질 필요는 없다.
* 필드가 반드시 생성자 선언 전에 선언되어야 하는 것은 아니다.

* 객체를 생성하려면 생성자 호출이 반드시 필요하다.
* 생성자는 다른 생성자를 호출하기 위해 this( )를 사용할 수 있다.

* 메소드 이름은 중복해서 선언할 수 있다.
* 메소드 오버로딩에서 리턴 타입은 상관이 없다.
* final필드는 생성자에서 초기화될 수 있지만 상수는 불가능하다.