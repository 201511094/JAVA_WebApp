07. 상속

[7.1] 상속 개념
* 상속은 코드의 중복을 줄여주며 효율적이고 개발 시간을 절약시켜준다.
* 상속을 해도 부모 클래스의 모든 필드와 메소드를 물려받는 것은 아니다.
 - 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외
 - 부모 클래스와 자식 클래스가 다른 패키지에 있다면 default 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외
* 상속을 이용하면 클래스의 수정을 최소화시킬 수 있다.
 - 부모 클래스의 수정이 모든 자식 클래스들의 수정 효과를 가져옴 -> 유지 보수 시간 최소화

[7.2] 클래스 상속
* 자식 클래스 선언 시 extends키워드 뒤에 부모 클래스를 기술한다.
* 자바는 다중 상속을 허용하지 않는다. extends 뒤에는 단 하나의 부모 클래스만 와야 한다.

[7.3] 부모 생성자 호출
* 자바에서 자식 객체를 생성하면 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.
* 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다. -> super( )
 - super( )는 부모의 기본 생성자를 호출함
 - super( )는 반드시 자식 생성자 첫 줄에 위치해야 함

[7.4] 메소드 재정의
* 부모 클래스의 모든 메소드가 자식 클래스에 맞게 설계되어 있다면 가장 이상적인 상속이지만, 일부가 적합하지 않은 경우 수정해서 사용해야 한다.
* 메소드 오버라이딩이란 상속된 메소드의 내용이 작식 클래스에 맞지 않을 경우 자식 클래스에서 동일한 메소드를 재정의하는 것이다.
 - 메소드가 오버라이딩되면 부모 객체의 메소드는 숨겨지기 때문에 자식 객체에서 메소드를 호출하면 오버라이딩된 자식 메소드가 호출됨
* 메소드 오버라이딩 규칙
 - 부모의 메소드와 동일한 시그너처(리턴타입, 메소드이름, 매개변수리스트)를 가져야 함
 - 접근 제한을 더 강하게 오버라이딩 할 수 없음
 - 새로운 예외(Exception)를 throws할 수 없음

* 자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이라면 super키워드를 붙여서 부모 메소드를 호출할 수 있다.
 - 부모 객체를 참조하고 있기 때문에 부모 메소드의 직접 접근 가능

[7.5] final 클래스와 final 메소드
* final키워드는 클래스, 필드, 메소드 선언 시 사용할 수 있다.
 - 클래스와 메소드 선언 시 final키워드가 지정되면 상속과 관련이 있음

* 클래스 선언 시 final키워드를 붙이면 상속할 수 없는 클래스가 된다. 즉 final 클래스는 자식 클래스를 만들 수 없다.
* 메소드 선언 시 final키워드를 붙이면 오버라이딩할 수 없는 메소드가 된다. 즉 final 메소드는 자식 클래스에서 재정의할 수 없다.

[7.6] protected 접근 제한자
* protected는 필드와 생성자, 메소드 선언에 사용될 수 있다.

[7.7] 타입 변환과 다형성
* 다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질이다.
 - 코드 측면에서 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해줌
* 다형성을 위해 자바는 부모 클래스로 타입 변환을 허용한다.
 - 부모 타입에 모든 자식 객체가 대입될 수 있고, 이를 이용하여 객체는 부품화가 가능해짐

* 자동 타입 변환(Promotion)은 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것이다.
* 자동 타입 변환의 개념은 자식이 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는 것이다.
* 부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다.
 - 단 메소드가 자식 클래스에서 오버라이딩되었다면 자식 클래스의 메소드가 대신 호출됨

* 다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질이며 주로 필드의 값을 다양화함으로써 실행 결과가 다르게 나오도록 구현한다.
* 필드의 타입은 변함이 없지만 실행 도중에 어떤 객체를 필드로 저장하느냐에 따라 실행결과가 달라질 수 있다.
 - 메소드의 수정 없이 다양한 실행 결과를 얻게 됨 -> 필드의 다형성

* 동일한 타입의 객체들은 배열로 관리하는 것이 유리하다.

* 자동 타입 변환은 필드 값을 대입할 때에도 발생하지만 주로 메소드를 호출할 때 많이 발생한다.
 - 메소드 호출 시 매개값을 다양화하기 위해 매개변수에 자식 타입 객체를 지정할 수 있음
* 매개 변수 타입이 클래스일 경우 해당 클래스의 객체뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다.

* 강제 타입 변환(Casting)은 부모 타입을 자식 타입으로 변환하는 것이다.
 - 자식 타입이 부모 타입으로 자동 변환한 후 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있음
* 어떤 객체가 어떤 클래스의 인스턴스인지 확인할 때 instanceof연산자를 사용할 수 있다.
 - boolean result = 객체 instanceof 타입;
* 타입을 확인하지 않고 강제 타입 변환을 시도하면 ClassCastException예외가 발생할 수 있다.

[7.8] 추상 클래스
* 실체 클래스란 객체를 직접 생성할 수 있는 클래스이며, 이 클래스들의 공통적인 특성을 추출해서 선언한 클래스를 추상 클래스라고 한다.
* 추상 클래스와 실체 클래스는 상속의 관계를 가지고 있으며 추상 클래스가 부모, 실체 클래스가 자식으로 구현되어 모든 특성을 물려받고 추가적인 특성을 가질 수 있다.
 - 특성이란 필드와 메소드
* 추상 클래스는 new연산자를 사용해서 인스턴스를 생성시키지 못한다.
 - 새로운 실체 클래스를 만들기 위해 부모 클래스로만 사용됨
 - extends 뒤에만 올 수 있는 클래스
* 추상 클래스의 용도
 - 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적: 추상 클래스에 필드와 메소드를 선언하고 자식 클래스가 이를 상속함으로써 이름을 통일시킴
 - 실체 클래스를 작성할 때 시간을 절약: 실체 클래스마다 다른 점만 선언하면 시간 절약 가능

* 추상 클래스 선언 시 클래스 선언에 abstract키워드를 붙인다.
* 추상 클래스도 일반 클래스처럼 필드, 생성자, 메소드 선언이 가능하며 자식 객체 생성 시 super( )를 통해 추상 클래스 객체를 생성하므로 생성자가 반드시 있어야 한다.

* 추상 클래스는 실체 클래스가 공통적으로 가져야 할 필드와 메소드들을 정의해 놓은 추상적인 클래스이므로 실체 클래스의 멤버(필드, 메소드)를 통일화하는데 목적이 있다.
* 추상 클래스는 추상 메소드를 선언할 수 있으며 추상 메소드는 추상 클래스에서만 선언할 수 있다.
 - 추상 메소드: 메소드의 선언부만 있고 메소드 실행 내용인 중괄호가 없는 메소드
* 추상 클래스 설계 시 하위 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은 메소드가 있을 경우 해당 메소드를 추상 메소드로 선언한다.
 - 자식 클래스는 반드시 추상 메소드를 재정의(오버라이딩)해서 실행 내용을 작성해야 함

[7.n] 확인문제
* 부모 객체가 항상 자식 타입으로 강제 타입 변환되는 것은 아니다.
* @Override 어노테이션을 사용하면 재정의가 확실한지 컴파일러가 검증한다.