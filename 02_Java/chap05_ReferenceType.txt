05. 참조 타입

[5.1] 데이터 타입 분류
* 자바의 데이터 타입: 기본 타입, 참조 타입
 - 기본 타입: 정수타입(byte/char/short/int/long), 실수타입(float/double), 논리타입(boolean)
 - 참조 타입 : 배열타입, 열거타입, 클래스, 인터페이스
* 기본 타입을 이용해 선언된 변수는 실제 값을 변수 안에 저장한다.
* 참조 타입을 이용해 선언된 변수는 메모리의 번지를 값으로 가지고 번지(주소)를 통해 객체를 참조한다.

* 변수는 스택 영역에 생성되고 객체는 힙 영역에 생성된다.

[5.2] 메모리 사용 영역
* java.exe를 통해 JVM이 시작되면 JVM은 메모리 영역을 세부 영역으로 구분해서 사용한다.
 메소드 영역
 - 코드에서 사용되는 클래스(.class)를 클래스 로더로 읽어 클래스별로 코드와 데이터를 분류해서 저장
 - 모든 스레드가 공유하는 영역
 힙 영역
 - 객체와 배열이 생성되는 영역. 이 객체와 배열은 JVM 스택영역의 변수나 다른 객체의 필드에서 참조
 - 참조하는 변수나 필드가 없으면 의미 없는 객체, 가비지 콜렉터가 쓰레기 객체를 힙 영역에서 자동으로 제거함
 JVM스택 영역
 - 각 스레드마다 존재, 스레드가 시작될 때 할당됨
 - 추가적으로 스레드를 생성하지 않았다면 main 스레드만 존재, 이 때 JVM스택은 하나이다.
 - 메소드를 호출할 때마다 프레임을 추가(push)하고 메소드가 종료되면 프레임을 제거(pop)하는 동작을 수행
 - 프레임 내부에는 로컬 변수 스택이 존재, 기본 타입 변수와 참조 타입 변수가 추가(push)되고 제거(pop)됨
 - 최초로 변수에 값이 저장될 때 변수가 이 영역에 생성됨
 - 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거됨

* 참조 타입 변수는 힙 영역이나 메소드 영역의 객체 주소를 가진다.
* 자바에서는 배열을 객체로 취급한다.

[5.3] 참조 변수의 ==, != 연산
* 기본 타입 변수의 연산은 변수의 값이 같은지 조사하지만, 참조 타입 변수들간의 연산은 동일한 객체를 참조하는지 조사한다.
* 참조 타입 변수의 값은 힙 영역의 객체 주소이고 결국 주소 값을 비교하게 된다.
* 동일한 주소 값을 갖고 있다는 것은 동일한 객체를 참조한다는 의미이다.
* 동일한 객체를 참조하고 있을 경우 ==연산의 결과가 true, 아니면 false이다.

[5.4] null과 NullPointerException
* 참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있다.
* null 값도 초기값으로 사용 가능하며 null로 초기화된 참조 변수는 스택 영역에 생성된다.
* 참조 타입 변수가 null 값을 가지는지 확인하려면 ==, != 연산을 수행하면 된다.
* 참조 타입 변수를 사용한다는 것은 객체를 사용한다는 것을 의미, 만약 null을 가지고 있을 경우 참조 타입 변수를 사용할 수 없다.
* NullPointerException은 참조 타입 변수가 null을 가지고 있어서(참조할 객체가 없으므로) 사용할 수 없는 경우에 발생한다.

[5.5] String 타입
* 자바는 문자열을 String변수에 저장하기 때문에 String변수를 우선 선언해야 한다. (String 변수명;)
* 문자열을 String변수에 저장한다는 말을 사용하지만 사실 틀린 표현이다.
 - 정확하게 말하면 문자열은 String객체로 생성되고 변수는 String객체를 참조하는 것
* 자바는 문자열 리터럴이 동일하다면 String객체를 공유하도록 되어 있다.

* 변수에 문자열을 저장할 경우 문자열 리터럴을 사용하지만, new연산자를 사용해서 직접 String객체를 생성시킬 수도 있다.
* new연산자는 객체 생성 연산자로, 힙 영역에 새로운 객체를 만들 때 사용하는 연산자이다.
* String객체 생성 방법에 따라 비교 연산자의 결과가 달라질 수 있다.(==연산자는 변수에 저장된 객체 번지가 동일한지 검사하기 때문)
* 객체에 상관없이 문자열만을 비교할 때에는 String객체의 equals( )메소드를 사용한다.
 - equals( )는 원본 문자열과 매개값으로 주어진 비교 문자열이 동일한지 비교한 후 true/false를 리턴
* String객체를 참조하는 참조 타입 변수에 null을 대입하면 더이상 String객체를 참조하지 않도록 할 수 있다.
 - 참조를 잃은 String객체는 JVM이 쓰레기 객체 취급을 하고 가비지 콜렉터를 구동시켜 메모리에서 자동으로 제거함

[5.6] 배열 타입
* 배열은 같은 타입의 데이터만 저장할 수 있다.
* 배열은 선언과 동시에 저장할 수 있는 데이터 타입이 결정되며 다른 타입을 저장하려고 하면 Type mismatch 컴파일 오류가 발생한다.
* 한 번 생성된 배열은 길이를 늘이거나 줄일 수 없다.

* 배열을 사용하기 위해 배열 변수를 선언해야 한다. 방법은 총 2가지로 타입[] 변수; 또는 타입 변수[];
* 배열 변수는 참조 변수에 속한다. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 된다.
* 참조할 배열 객체가 없으면 배열 변수는 null 값으로 초기화될 수 있다.
 - 만약 배열 변수가 null값을 가진 상태에서 값을 읽거나 저장하려고 하면 NullPointerException이 발생한다.
 - 배열 변수는 배열을 생성하고 참조하는 상태에서 값을 저장하거나 읽어야 한다.
* 배열 변수를 이미 선언한 후에( 타입[ ] 변수; ) 다른 실행문에서 중괄호를 사용한 배열 생성( 변수={ 1,2,3, ... }; )은 허용하지 않는다.
 - new연산자를 사용해서 값 목록을 지정해줄 수 있다. -> 변수=new 타입[ ]{ 1,2,3, ... };
* 배열이 메소드의 매개값일 경우에도 new연산자를 사용해야 한다. -> int result=add( new int[ ] { 1,2,3 } );
* 값의 목록이 아직 없지만 향후 값들을 저장할 배열을 미리 만들고 싶다면 new연산자를 통해 배열 객체를 생성할 수 있다. -> 타입[ ] 변수=new 타입[길이];
* 배열 객체를 생성하게 되면 값이 저장될 수 있는 공간을 확보하고 배열의 생성 번지를 리턴한다. 리턴된 번지는 변수에 저장된다.
* 배열의 길이란 배열에 저장할 수 있는 전체 항목 수이며 배열 객체의 length필드(필드: 객체 내부의 데이터)를 읽으면 된다.

* 커맨드 라인 입력: main( )메소드의 String[ ] args
 - 프로그램 실행을 위해 main( )메소드가 필요하다. 
 - "java 클래스"로 프로그램을 실행하면 JVM은 길이가 0인 배열을 생성하고 main( )메소드를 호출할 때 매개값으로 전달함
 - main( )메소드는 String[ ] args매개변수를 통해 커맨드 라인에서 입력된 데이터의 수(배열의 길이)와 입력된 데이터(배열의 항목 값)를 알 수 있음

* 객체를 참조하는 배열의 경우 배열의 각 항목도 변수와 동일하게 취급되어야 한다.
 - String[ ]배열 항목 간의 문자열 비교할 때 ==(객체의 번지 비교연산자) 대신 equals()메소드를 사용해야 함

* 배열의 크기를 변경할 수 없으므로 더 많은 저장공간이 필요하다면 새로운 배열을 생성한 후 기존 배열 항목을 새 배열로 복사해야 한다.
 - 반복문이나 System.arraycopy( )메소드 사용
 - System.arraycopy(원본배열, 원본배열 시작인덱스, 새 배열, 새 배열 시작인덱스, 복사할 개수)
 - 참조 타입 배열일 경우 배열 복사 시 복사되는 값이 객체의 번지이므로 새 배열의 항목은 그대로 기존 배열의 항목이 참조하는 객체와 동일(=얕은 복사)
 - 얕은 복사(shallow copy) <-> 깊은 복사(deep copy): 참조하는 객체도 별도로 생성하는 것

* 향상된 for문은 반복 실행 시 카운터 변수와 증감식을 사용하지 않는다. 배열 및 컬렉션 항목의 개수만큼 반복하고 자동적으로 루프를 빠져나간다.
 - for (타입변수: 배열) { 실행문; }
 - for문 처음 실행 시 배열에서 가져올 값이 존재하는지 평가하고, 존재하면 해당 값을 변수에 저장한 후 실행문을 실행
 - 다시 루프를 돌아 배열에서 가져올 다음 값이 존재하는지 평가하고 가져올 항목이 없으면 for문이 종료된다.
 - 향상된 for문의 반복 횟수는 배열의 항목 수이다.

[5.7] 열거 타입
* 열거 타입은 한정된 값만 갖는 데이터 타입으로 몇 개의 열거 상수 중에서 하나의 상수를 저장하는 데이터 타입이다.
* 열거 타입을 선언할 때에는 열거 타입의 이름을 정하고 열거 타입 이름으로 소스 파일을 생성한다.(.java)
 - public enum키워드는 열거 타입을 선언하기 위한 키워드
 - 열거 타입 이름은 소스 파일명과 대소문자가 모두 일치해야 함
* 열거 타입을 선언한 후 열거 상수를 선언한다.
 - 열거 상수는 열거 타입의 값으로 사용되며 모두 대문자로 작성한다.

* 열거 타입도 하나의 데이터 타입이므로 변수를 선언하고 사용해야 한다.( 열거타입 변수; )
* 열거 타입 변수를 선언한 후 열거 상수를 저장할 수 있다. 반드시 열거타입.열거상수로 사용해야 한다. ( 열거타입 변수=열거타입.열거상수; )
* 열거 타입 변수는 null값을 저장할 수 있다.(열거 타입도 참조 타입이기 때문)
* 열거 상수는 열거 객체로 생성되므로 객체이다.
 - 열거 타입 변수는 스택영역에 생성되고, 변수에 저장되는 값은 열거 상수가 참조하는 객체의 번지이다.

* 열거 객체는 열거 상수의 문자열을 내부 데이터로 가지고 있다.
 - 모든 열거 타입은 컴파일 시 Enum클래스를 상속하게 되어 있음
 - 열거 객체가 가지는 데이터 및 메소드들
 - 메소드: name(), ordinal(), compareTo(), valueOf(), values() -> java.lang.Enum클래스에 선언된 메소드들