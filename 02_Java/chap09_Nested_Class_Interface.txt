09. 중첩 클래스와 중첩 인터페이스

[9.1] 중첩 클래스와 중첩 인터페이스란?
* 중첩 클래스란 클래스 내부에 선언한 클래스이다.
* 중첩 클래스를 사용하면 두 클래스의 멤버들을 서로 쉽게 접근할 수 있다는 장점이 있고 외부에는 불필요한 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다.

* 중첩 인터페이스는 클래스 내부에 선언한 인터페이스이다.
* 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해 중첩 인터페이스를 사용한다.
 - 주로 UI 프로그래밍에서 이벤트 처리 목적으로 많이 활용

[9.2] 중첩 클래스
* 클래스의 멤버로서 선언되는 중첩 클래스를 멤버 클래스, 메소드 내부에서 선언되는 중첩 클래스를 로컬 클래스라고 한다.
 - 멤버 클래스는 클래스나 객체가 사용 중이라면 언제든지 재사용이 가능하지만 로컬 클래스는 메소드 실행 시에만 사용되며 메소드가 실행 종료되면 없어짐
* 멤버 클래스도 하나의 클래스이기 때문에 컴파일하면 바이트 코드 파일(.class)이 별도로 생성된다.
 - A $ B .class (멤버 클래스)
 - A $1 B .class (로컬 클래스)

* 인스턴스 멤버 클래스는 static키워드 없이 선언된 클래스이다. 인스턴스 필드와 메소드만 선언이 가능하고 정적 필드와 메소드는 선언할 수 없다.
 - A클래스 외부에서 인스턴스 멤버 클래스 B의 객체를 생성하려면 먼저 A객체를 생성하고 B객체를 생성해야 함
* 정적 멤버 클래스는 static키워드로 선언된 클래스이다. 모든 종류의 필드와 메소드를 선언할 수 있다.
 - A클래스 외부에서 정적 멤버 클래스 C의 객체를 생성하려면 A객체를 생성할 필요 없이 A.C로 C객체를 생성하면 됨

* 로컬 클래스는 접근 제한자와 static을 붙일 수 없다.
 - 메소드 내부에서만 사용되므로 접근을 제한할 필요가 없기 때문
* 로컬 클래스 내부에는 인스턴스 필드와 메소드만 선언이 가능하고 정적 필드와 메소드는 선언할 수 없다.
* 로컬 클래스는 주로 비동기 처리를 위해 스레드 객체를 만들 때 사용한다.

[9.3] 중첩 클래스의 접근 제한
* 바깥 필드와 메소드에서 사용 제한
* 멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 바깥 클래스의 필드와 메소드에 사용 제한이 생긴다.
 - 인스턴스 멤버 클래스는 바깥 클래스의 인스턴스 필드의 초기값이나 및 인스턴스 메소드에서 객체를 생성할 수 있음
 - 인스턴스 멤버 클래스는 정적 필드의 초기값이나 정적 메소드에서는 객체를 생성할 수 없음
 - 정적 멤버 클래스는 모든 필드의 초기값이나 모든 메소드에서 객체를 생성할 수 있음

* 멤버 클래스에서 사용 제한
* 멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 멤버 클래스 내부에서 바깥 클래스의 필드와 메소드를 접근할 때에도 제한이 생긴다.
 - 인스턴스 멤버 클래스 안에서는 바깥 클래스의 모든 필드와 모든 메소드에 접근 가능
 - 정적 멤버 클래스 안에서는 바깥 클래스의 정적 필드와 메소드에만 접근 가능, 인스턴스 필드와 메소드는 접근 불가능

* 로컬 클래스에서 사용 제한
* 로컬 클래스 내부에서는 바깥 클래스의 필드나 메소드를 제한 없이 사용할 수 있다.
* 메소드의 매개 변수나 로컬 변수를 로컬 클래스에서 사용할 경우, 로컬 클래스의 객체는 메소드 실행이 끝나도 힙 메모리에 존재해서 계속 사용될 수 있다.
 - 매개 변수나 로컬 변수는 메소드 실행이 끝나면 스택 메모리에서 사라지므로 로컬 객체에서 사용할 경우 문제가 발생함
* 이를 해결하기 위해 자바는 컴파일 시 로컬 클래스에서 사용하는 매개 변수나 로컬 변수의 값을 로컬 클래스 내부에 복사해 두고 사용한다.
 - 매개 변수나 로컬 변수가 수정되어 값이 변경되면 복사해 둔 값과 달라지는 문제를 해결하기 위해 매개 변수나 로컬 변수를 final로 선언하여 수정을 막음
* 로컬 클래스에서 사용 하능한 것은 final로 선언된 매개 변수와 로컬 변수뿐이다.
 - 자바8부터 final없이 선언된 매개 변수와 로컬 변수를 사용해도 컴파일 에러가 나지 않으며 final선언을 하지 않아도 final특성을 가짐
* final키워드 존재 여부의 차이점은 로컬 클래스 복사 위치이다.
 - final키워드가 있다면 로컬 클래스의 메소드 내부에 지역 변수로 복사됨
 - final키워드가 없다면 로컬 클래스의 필드로 복사됨
* 로컬 클래스에서 사용된 매개 변수와 로컬 변수는 모두 final 특성을 갖는다.

* 중첩 클래스에서 바깥 클래스 참조 얻기
* 클래스 내부에서 this는 객체 자신의 참조이며 중첩 클래스에서 this키워드를 사용하면 바깥 클래스가 아닌 중첩 클래스의 객체 참조가 된다.
 - this.필드, this.메소드( )
* 중첩 클래스 내부에서 바깥 클래스의 객체 참조를 얻으려면 바깥 클래스 이름을 this 앞에 붙여준다.
 - 바깥클래스.this.필드, 바깥클래스.this.메소드( )

[9.4] 중첩 인터페이스
* 중첩 인터페이스는 클래스의 멤버로 선언된 인터페이스이다.
* 인터페이스를 클래스 내부에 선언하는 이유는 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들기 위해서이다.
 - UI 프로그래밍에서 이벤트 처리 목적으로 많이 활용

[9.5] 익명 객체
* 익명 객체는 이름이 없는 객체이다.
* 익명 객체는 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이스를 구현해야 생성할 수 있다.
* 익명 객체는 필드의 초기값이나 로컬 변수의 초기값, 매개 변수의 매개값으로 주로 대입된다.
 - UI 이벤트 처리 객체나 스레드 객체를 간편하게 생성할 목적으로 많이 활용됨
* 부모 타입으로 필드나 변수를 선언하고 자식 객체를 초기값으로 대입할 경우,
 자식 클래스가 재사용되지 않고 오직 해당 필드와 변수의 초기값으로만 사용한다면 익명 자식 객체를 생성해서 초기값으로 대입하는 것이 좋은 방법이다.
 - 실행문의 끝에 세미콜론(;) 필수

* 익명 자식 객체에 새롭게 정의된 필드와 메소드는 익명 자식 객체 내부에서만 사용된다. 외부에서는 필드와 메소드에 접근할 수 없다.
 - 익명 자식 객체는 부모 타입 변수에 대입되므로 부모 타입에 선언된 것만 사용할 수 있기 때문

* 익명 구현 객체 생성
* 인터페이스 타입으로 필드나 변수를 선언하고 구현 객체를 초기값으로 대입하는 경우
 - 구현 클래스를 선언하고 new연산자를 이용해서 구현 객체를 생성한 후 필드나 로컬 변수에 대임
 - 구현 클래스가 재사용되지 않고 해당 필드의 변수의 초기값으로만 사용한다면, 익명 구현 객체를 초기값으로 대입하는 것이 좋음

* 익명 객체의 로컬 변수 사용
* 로컬 클래스와 익명 클래스와의 차이점은 클래스 이름의 존재 여부만 다를 뿐 동작 방식은 동일하다.
* 익명 객체 내부에서 메소드의 매개 변수나 로컬 변수를 사용할 경우 이 변수들은 final 특성을 가진다.

[9.n] 확인문제
* 인스턴스 멤버 클래스는 바깥 클래스의 객체가 있어야 사용될 수 있다.
* 정적 멤버 클래스는 바깥 클래스의 객체가 없어도 사용될 수 있다.
* 인스턴스 멤버 클래스 내부에는 바깥 클래스의 모든 필드와 메소드를 사용할 수 있다.
* 정적 멤버 클래스 내부에는 바깥 클래스의 인스턴스 필드를 사용할 수 없다.

* 로컬 클래스는 바깥 클래스의 모든 필드와 메소드를 사용할 수 있다.
* 로컬 클래스는 static키워드를 사용할 수 없고 접근 제한자도 사용할 수 없다.
* final특성을 가진 매개 변수나 로컬 변수만 로컬 변수에서 사용할 수 있다.